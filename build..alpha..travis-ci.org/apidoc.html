<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/markdown-it/markdown-it#readme"

    >markdown-it (v8.3.1)</a>
</h1>
<h4>Markdown-it - modern pluggable markdown parser.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it">module markdown-it</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.markdown-it">
            function <span class="apidocSignatureSpan"></span>markdown-it
            <span class="apidocSignatureSpan">(presetName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_block">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_core">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_core
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_inline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer">
            function <span class="apidocSignatureSpan">markdown-it.</span>renderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler">
            function <span class="apidocSignatureSpan">markdown-it.</span>ruler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_block
            <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_core">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_core
            <span class="apidocSignatureSpan">(src, md, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_inline
            <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token">
            function <span class="apidocSignatureSpan">markdown-it.</span>token
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>emphasis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>parser_block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>parser_core.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>parser_inline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>renderer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>ruler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>state_block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>state_core.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>state_inline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>strikethrough</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>token.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.emphasis">module markdown-it.emphasis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.emphasis.postProcess">
            function <span class="apidocSignatureSpan">markdown-it.emphasis.</span>postProcess
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.emphasis.tokenize">
            function <span class="apidocSignatureSpan">markdown-it.emphasis.</span>tokenize
            <span class="apidocSignatureSpan">(state, silent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_block">module markdown-it.parser_block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_block.parser_block">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_block.prototype">module markdown-it.parser_block.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_block.prototype.State">
            function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>State
            <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_block.prototype.parse">
            function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>parse
            <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_block.prototype.tokenize">
            function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>tokenize
            <span class="apidocSignatureSpan">(state, startLine, endLine)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_core">module markdown-it.parser_core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_core.parser_core">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_core
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_core.prototype">module markdown-it.parser_core.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_core.prototype.State">
            function <span class="apidocSignatureSpan">markdown-it.parser_core.prototype.</span>State
            <span class="apidocSignatureSpan">(src, md, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_core.prototype.process">
            function <span class="apidocSignatureSpan">markdown-it.parser_core.prototype.</span>process
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_inline">module markdown-it.parser_inline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline.parser_inline">
            function <span class="apidocSignatureSpan">markdown-it.</span>parser_inline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.parser_inline.prototype">module markdown-it.parser_inline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline.prototype.State">
            function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>State
            <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline.prototype.parse">
            function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>parse
            <span class="apidocSignatureSpan">(str, md, env, outTokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline.prototype.skipToken">
            function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>skipToken
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.parser_inline.prototype.tokenize">
            function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>tokenize
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.renderer">module markdown-it.renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.renderer">
            function <span class="apidocSignatureSpan">markdown-it.</span>renderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.renderer.prototype">module markdown-it.renderer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.prototype.render">
            function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>render
            <span class="apidocSignatureSpan">(tokens, options, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.prototype.renderAttrs">
            function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderAttrs
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.prototype.renderInline">
            function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderInline
            <span class="apidocSignatureSpan">(tokens, options, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.prototype.renderInlineAsText">
            function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderInlineAsText
            <span class="apidocSignatureSpan">(tokens, options, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.renderer.prototype.renderToken">
            function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderToken
            <span class="apidocSignatureSpan">(tokens, idx, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.ruler">module markdown-it.ruler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.ruler">
            function <span class="apidocSignatureSpan">markdown-it.</span>ruler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.ruler.prototype">module markdown-it.ruler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.__compile__">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>__compile__
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.__find__">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>__find__
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.after">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>after
            <span class="apidocSignatureSpan">(afterName, ruleName, fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.at">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>at
            <span class="apidocSignatureSpan">(name, fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.before">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>before
            <span class="apidocSignatureSpan">(beforeName, ruleName, fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.disable">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>disable
            <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.enable">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>enable
            <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.enableOnly">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>enableOnly
            <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.getRules">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>getRules
            <span class="apidocSignatureSpan">(chainName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.ruler.prototype.push">
            function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>push
            <span class="apidocSignatureSpan">(ruleName, fn, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_block">module markdown-it.state_block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.state_block">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_block
            <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_block.prototype">module markdown-it.state_block.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.Token">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>Token
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.getLines">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>getLines
            <span class="apidocSignatureSpan">(begin, end, indent, keepLastLF)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.isEmpty">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.push">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>push
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.skipChars">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipChars
            <span class="apidocSignatureSpan">(pos, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.skipCharsBack">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipCharsBack
            <span class="apidocSignatureSpan">(pos, code, min)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.skipEmptyLines">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipEmptyLines
            <span class="apidocSignatureSpan">(from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.skipSpaces">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipSpaces
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_block.prototype.skipSpacesBack">
            function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipSpacesBack
            <span class="apidocSignatureSpan">(pos, min)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_core">module markdown-it.state_core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_core.state_core">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_core
            <span class="apidocSignatureSpan">(src, md, env)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_core.prototype">module markdown-it.state_core.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_core.prototype.Token">
            function <span class="apidocSignatureSpan">markdown-it.state_core.prototype.</span>Token
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_inline">module markdown-it.state_inline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline.state_inline">
            function <span class="apidocSignatureSpan">markdown-it.</span>state_inline
            <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.state_inline.prototype">module markdown-it.state_inline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline.prototype.Token">
            function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>Token
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline.prototype.push">
            function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>push
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline.prototype.pushPending">
            function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>pushPending
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.state_inline.prototype.scanDelims">
            function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>scanDelims
            <span class="apidocSignatureSpan">(start, canSplitWord)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.strikethrough">module markdown-it.strikethrough</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.strikethrough.postProcess">
            function <span class="apidocSignatureSpan">markdown-it.strikethrough.</span>postProcess
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.strikethrough.tokenize">
            function <span class="apidocSignatureSpan">markdown-it.strikethrough.</span>tokenize
            <span class="apidocSignatureSpan">(state, silent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.token">module markdown-it.token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.token">
            function <span class="apidocSignatureSpan">markdown-it.</span>token
            <span class="apidocSignatureSpan">(type, tag, nesting)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.token.prototype">module markdown-it.token.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.prototype.attrGet">
            function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrGet
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.prototype.attrIndex">
            function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrIndex
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.prototype.attrJoin">
            function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrJoin
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.prototype.attrPush">
            function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrPush
            <span class="apidocSignatureSpan">(attrData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.token.prototype.attrSet">
            function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrSet
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.markdown-it.utils">module markdown-it.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.arrayReplaceAt">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>arrayReplaceAt
            <span class="apidocSignatureSpan">(src, pos, newElements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.assign">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>assign
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.escapeHtml">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>escapeHtml
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.escapeRE">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>escapeRE
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.fromCodePoint">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>fromCodePoint
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.has">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>has
            <span class="apidocSignatureSpan">(object, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isMdAsciiPunct">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isMdAsciiPunct
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isPunctChar">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isPunctChar
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isSpace">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isSpace
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isString">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isString
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isValidEntityCode">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isValidEntityCode
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.isWhiteSpace">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>isWhiteSpace
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.normalizeReference">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>normalizeReference
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.unescapeAll">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>unescapeAll
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.markdown-it.utils.unescapeMd">
            function <span class="apidocSignatureSpan">markdown-it.utils.</span>unescapeMd
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">markdown-it.utils.</span>lib</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it" id="apidoc.module.markdown-it">module markdown-it</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.markdown-it" id="apidoc.element.markdown-it.markdown-it">
        function <span class="apidocSignatureSpan"></span>markdown-it
        <span class="apidocSignatureSpan">(presetName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = &#x27;default&#x27;;
    }
  }

<span class="apidocCodeCommentSpan">  /**
   * MarkdownIt#inline -&#x3e; ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
</span>  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -&#x3e; ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -&#x3e; Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -&#x3e; Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require(&#x27;markdown-it&#x27;)();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules[&#x27;my_token&#x27;] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -&#x3e; LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -&#x3e; Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require(&#x27;markdown-it&#x27;)();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -&#x3e; String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -&#x3e; String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;


  // Expose utils &#x26; helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -&#x3e; utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -&#x3e; helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_block" id="apidoc.element.markdown-it.parser_block">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParserBlock() {
<span class="apidocCodeCommentSpan">  /**
   * ParserBlock#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
</span>  this.ruler = new Ruler();

  for (var i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_core" id="apidoc.element.markdown-it.parser_core">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_core
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Core() {
<span class="apidocCodeCommentSpan">  /**
   * Core#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
</span>  this.ruler = new Ruler();

  for (var i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline" id="apidoc.element.markdown-it.parser_inline">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_inline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParserInline() {
  var i;

<span class="apidocCodeCommentSpan">  /**
   * ParserInline#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
</span>  this.ruler = new Ruler();

  for (i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -&#x3e; Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i &#x3c; _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.renderer" id="apidoc.element.markdown-it.renderer">
        function <span class="apidocSignatureSpan">markdown-it.</span>renderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Renderer() {

<span class="apidocCodeCommentSpan">  /**
   * Renderer#rules -&#x3e; Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require(&#x27;markdown-it&#x27;)();
   *
   * md.renderer.rules.strong_open  = function () { return &#x27;&#x3c;b&#x3e;&#x27;; };
   * md.renderer.rules.strong_close = function () { return &#x27;&#x3c;/b&#x3e;&#x27;; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
</span>  this.rules = assign({}, default_rules);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler" id="apidoc.element.markdown-it.ruler">
        function <span class="apidocSignatureSpan">markdown-it.</span>ruler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, &#x27;&#x27; for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block" id="apidoc.element.markdown-it.state_block">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_block
        <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It&#x27;s used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn&#x27;t any)

  // can be &#x27;blockquote&#x27;, &#x27;list&#x27;, &#x27;root&#x27;, &#x27;paragraph&#x27; or &#x27;reference&#x27;
  // used in lists to determine if they interrupt a paragraph
  this.parentType = &#x27;root&#x27;;

  this.level = 0;

  // renderer
  this.result = &#x27;&#x27;;

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos &#x3c; len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don&#x27;t count last fake line
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_core" id="apidoc.element.markdown-it.state_core">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_core
        <span class="apidocSignatureSpan">(src, md, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_inline" id="apidoc.element.markdown-it.state_inline">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_inline
        <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = &#x27;&#x27;;
  this.pendingLevel = 0;

  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  this.delimiters = [];   // Emphasis-like delimiters
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.token" id="apidoc.element.markdown-it.token">
        function <span class="apidocSignatureSpan">markdown-it.</span>token
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(type, tag, nesting) {
<span class="apidocCodeCommentSpan">  /**
   * Token#type -&#x3e; String
   *
   * Type of the token (string, e.g. &#x22;paragraph_open&#x22;)
   **/
</span>  this.type     = type;

  /**
   * Token#tag -&#x3e; String
   *
   * html tag name, e.g. &#x22;p&#x22;
   **/
  this.tag      = tag;

  /**
   * Token#attrs -&#x3e; Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -&#x3e; Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -&#x3e; Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -&#x3e; Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -&#x3e; Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -&#x3e; String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = &#x27;&#x27;;

  /**
   * Token#markup -&#x3e; String
   *
   * &#x27;*&#x27; or &#x27;_&#x27; for emphasis, fence string for fence, etc.
   **/
  this.markup   = &#x27;&#x27;;

  /**
   * Token#info -&#x3e; String
   *
   * fence infostring
   **/
  this.info     = &#x27;&#x27;;

  /**
   * Token#meta -&#x3e; Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -&#x3e; Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -&#x3e; Boolean
   *
   * If it&#x27;s true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.emphasis" id="apidoc.module.markdown-it.emphasis">module markdown-it.emphasis</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.emphasis.postProcess" id="apidoc.element.markdown-it.emphasis.postProcess">
        function <span class="apidocSignatureSpan">markdown-it.emphasis.</span>postProcess
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i &#x3c; max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F/* _ */ &#x26;&#x26; startDelim.marker !== 0x2A/* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `&#x3c;em&#x3e;&#x3c;em&#x3e;whatever&#x3c;/em&#x3e;&#x3c;/em&#x3e;` -&#x3e; `&#x3c;strong&#x3e;whatever&#x3c;/strong&#x3e;`
    //
    isStrong = i + 1 &#x3c; max &#x26;&#x26;
               delimiters[i + 1].end === startDelim.end - 1 &#x26;&#x26;
               delimiters[i + 1].token === startDelim.token + 1 &#x26;&#x26;
               delimiters[startDelim.end - 1].token === endDelim.token - 1 &#x26;&#x26;
               delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token         = state.tokens[startDelim.token];
    token.type    = isStrong ? &#x27;strong_open&#x27; : &#x27;em_open&#x27;;
    token.tag     = isStrong ? &#x27;strong&#x27; : &#x27;em&#x27;;
    token.nesting = 1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = &#x27;&#x27;;

    token         = state.tokens[endDelim.token];
    token.type    = isStrong ? &#x27;strong_close&#x27; : &#x27;em_close&#x27;;
    token.tag     = isStrong ? &#x27;strong&#x27; : &#x27;em&#x27;;
    token.nesting = -1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = &#x27;&#x27;;

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = &#x27;&#x27;;
      state.tokens[delimiters[startDelim.end - 1].token].content = &#x27;&#x27;;
      i++;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.emphasis.tokenize" id="apidoc.element.markdown-it.emphasis.tokenize">
        function <span class="apidocSignatureSpan">markdown-it.emphasis.</span>tokenize
        <span class="apidocSignatureSpan">(state, silent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emphasis(state, silent) {
  var i, scanned, token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ &#x26;&#x26; marker !== 0x2A /* * */) { return false; }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i &#x3c; scanned.length; i++) {
    token         = state.push(&#x27;text&#x27;, &#x27;&#x27;, 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that&#x27;s equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like &#x22;*****&#x22; in one step, for 1st asterisk
      // value will be 0, for 2nd it&#x27;s 1 and so on.
      //
      jump:   i,

      // A position of the token this delimiter corresponds to.
      //
      token:  state.tokens.length - 1,

      // Token level.
      //
      level:  state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it&#x27;s `-1`.
      //
      end:    -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.<span class="apidocCodeKeywordSpan">tokenize</span>(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require(&#x27;./rules_block/state_block&#x27;);


module.exports = ParserBlock;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_block" id="apidoc.module.markdown-it.parser_block">module markdown-it.parser_block</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_block.parser_block" id="apidoc.element.markdown-it.parser_block.parser_block">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParserBlock() {
<span class="apidocCodeCommentSpan">  /**
   * ParserBlock#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
</span>  this.ruler = new Ruler();

  for (var i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_block.prototype" id="apidoc.module.markdown-it.parser_block.prototype">module markdown-it.parser_block.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_block.prototype.State" id="apidoc.element.markdown-it.parser_block.prototype.State">
        function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>State
        <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It&#x27;s used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn&#x27;t any)

  // can be &#x27;blockquote&#x27;, &#x27;list&#x27;, &#x27;root&#x27;, &#x27;paragraph&#x27; or &#x27;reference&#x27;
  // used in lists to determine if they interrupt a paragraph
  this.parentType = &#x27;root&#x27;;

  this.level = 0;

  // renderer
  this.result = &#x27;&#x27;;

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos &#x3c; len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don&#x27;t count last fake line
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== &#x27;string&#x27;) {
    throw new Error(&#x27;Input data should be a String&#x27;);
  }

  var state = new this.core.<span class="apidocCodeKeywordSpan">State</span>(src, this, env);

  this.core.process(state);

  return state.tokens;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_block.prototype.parse" id="apidoc.element.markdown-it.parser_block.prototype.parse">
        function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>parse
        <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ &#x27;http:&#x27;, &#x27;https:&#x27;, &#x27;mailto:&#x27; ];

function normalizeLink(url) {
var parsed = mdurl.<span class="apidocCodeKeywordSpan">parse</span>(url, true);

if (parsed.hostname) {
  // Encode hostnames in urls like:
  // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
  //
  // We don&#x27;t encode unknown schemas, because it&#x27;s likely that we encode
  // something we shouldn&#x27;t (e.g. `skype:name` treated as `skype:host`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_block.prototype.tokenize" id="apidoc.element.markdown-it.parser_block.prototype.tokenize">
        function <span class="apidocSignatureSpan">markdown-it.parser_block.prototype.</span>tokenize
        <span class="apidocSignatureSpan">(state, startLine, endLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenize = function (state, startLine, endLine) {
  var ok, i,
      rules = this.ruler.getRules(&#x27;&#x27;),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line &#x3c; endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line &#x3e;= endLine) { break; }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes &#x26; lists
    if (state.sCount[line] &#x3c; state.blkIndent) { break; }

    // If nesting level exceeded - skip tail to the end. That&#x27;s not ordinary
    // situation and we should not care about content.
    if (state.level &#x3e;= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i &#x3c; len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) { break; }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might &#x22;eat&#x22; one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line &#x3c; endLine &#x26;&#x26; state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.<span class="apidocCodeKeywordSpan">tokenize</span>(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require(&#x27;./rules_block/state_block&#x27;);


module.exports = ParserBlock;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_core" id="apidoc.module.markdown-it.parser_core">module markdown-it.parser_core</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_core.parser_core" id="apidoc.element.markdown-it.parser_core.parser_core">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_core
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Core() {
<span class="apidocCodeCommentSpan">  /**
   * Core#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
</span>  this.ruler = new Ruler();

  for (var i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_core.prototype" id="apidoc.module.markdown-it.parser_core.prototype">module markdown-it.parser_core.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_core.prototype.State" id="apidoc.element.markdown-it.parser_core.prototype.State">
        function <span class="apidocSignatureSpan">markdown-it.parser_core.prototype.</span>State
        <span class="apidocSignatureSpan">(src, md, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== &#x27;string&#x27;) {
    throw new Error(&#x27;Input data should be a String&#x27;);
  }

  var state = new this.core.<span class="apidocCodeKeywordSpan">State</span>(src, this, env);

  this.core.process(state);

  return state.tokens;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_core.prototype.process" id="apidoc.element.markdown-it.parser_core.prototype.process">
        function <span class="apidocSignatureSpan">markdown-it.parser_core.prototype.</span>process
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules(&#x27;&#x27;);

  for (i = 0, l = rules.length; i &#x3c; l; i++) {
    rules[i](state);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
MarkdownIt.prototype.parse = function (src, env) {
 if (typeof src !== &#x27;string&#x27;) {
   throw new Error(&#x27;Input data should be a String&#x27;);
 }

 var state = new this.core.State(src, this, env);

 this.core.<span class="apidocCodeKeywordSpan">process</span>(state);

 return state.tokens;
};


/**
* MarkdownIt.render(src [, env]) -&#x3e; String
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_inline" id="apidoc.module.markdown-it.parser_inline">module markdown-it.parser_inline</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline.parser_inline" id="apidoc.element.markdown-it.parser_inline.parser_inline">
        function <span class="apidocSignatureSpan">markdown-it.</span>parser_inline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParserInline() {
  var i;

<span class="apidocCodeCommentSpan">  /**
   * ParserInline#ruler -&#x3e; Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
</span>  this.ruler = new Ruler();

  for (i = 0; i &#x3c; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -&#x3e; Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i &#x3c; _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.parser_inline.prototype" id="apidoc.module.markdown-it.parser_inline.prototype">module markdown-it.parser_inline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline.prototype.State" id="apidoc.element.markdown-it.parser_inline.prototype.State">
        function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>State
        <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = &#x27;&#x27;;
  this.pendingLevel = 0;

  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  this.delimiters = [];   // Emphasis-like delimiters
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== &#x27;string&#x27;) {
    throw new Error(&#x27;Input data should be a String&#x27;);
  }

  var state = new this.core.<span class="apidocCodeKeywordSpan">State</span>(src, this, env);

  this.core.process(state);

  return state.tokens;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline.prototype.parse" id="apidoc.element.markdown-it.parser_inline.prototype.parse">
        function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>parse
        <span class="apidocSignatureSpan">(str, md, env, outTokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules(&#x27;&#x27;);
  len = rules.length;

  for (i = 0; i &#x3c; len; i++) {
    rules[i](state);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ &#x27;http:&#x27;, &#x27;https:&#x27;, &#x27;mailto:&#x27; ];

function normalizeLink(url) {
var parsed = mdurl.<span class="apidocCodeKeywordSpan">parse</span>(url, true);

if (parsed.hostname) {
  // Encode hostnames in urls like:
  // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
  //
  // We don&#x27;t encode unknown schemas, because it&#x27;s likely that we encode
  // something we shouldn&#x27;t (e.g. `skype:name` treated as `skype:host`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline.prototype.skipToken" id="apidoc.element.markdown-it.parser_inline.prototype.skipToken">
        function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>skipToken
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipToken = function (state) {
  var ok, i, pos = state.pos,
      rules = this.ruler.getRules(&#x27;&#x27;),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;


  if (typeof cache[pos] !== &#x27;undefined&#x27;) {
    state.pos = cache[pos];
    return;
  }

  if (state.level &#x3c; maxNesting) {
    for (i = 0; i &#x3c; len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It&#x27;s harmless to do here, because no tokens are created. But ideally,
      // we&#x27;d need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) { break; }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (level === 0) {
    found = true;
    break;
  }
}

prevPos = state.pos;
state.md.inline.<span class="apidocCodeKeywordSpan">skipToken</span>(state);
if (marker === 0x5B /* [ */) {
  if (prevPos === state.pos - 1) {
    // increase level if we find text `[`, which is not a part of any token
    level++;
  } else if (disableNested) {
    state.pos = oldPos;
    return -1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.parser_inline.prototype.tokenize" id="apidoc.element.markdown-it.parser_inline.prototype.tokenize">
        function <span class="apidocSignatureSpan">markdown-it.parser_inline.prototype.</span>tokenize
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenize = function (state) {
  var ok, i,
      rules = this.ruler.getRules(&#x27;&#x27;),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos &#x3c; end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level &#x3c; maxNesting) {
      for (i = 0; i &#x3c; len; i++) {
        ok = rules[i](state, false);
        if (ok) { break; }
      }
    }

    if (ok) {
      if (state.pos &#x3e;= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.<span class="apidocCodeKeywordSpan">tokenize</span>(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require(&#x27;./rules_block/state_block&#x27;);


module.exports = ParserBlock;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.renderer" id="apidoc.module.markdown-it.renderer">module markdown-it.renderer</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.renderer.renderer" id="apidoc.element.markdown-it.renderer.renderer">
        function <span class="apidocSignatureSpan">markdown-it.</span>renderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Renderer() {

<span class="apidocCodeCommentSpan">  /**
   * Renderer#rules -&#x3e; Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require(&#x27;markdown-it&#x27;)();
   *
   * md.renderer.rules.strong_open  = function () { return &#x27;&#x3c;b&#x3e;&#x27;; };
   * md.renderer.rules.strong_close = function () { return &#x27;&#x3c;/b&#x3e;&#x27;; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
</span>  this.rules = assign({}, default_rules);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.renderer.prototype" id="apidoc.module.markdown-it.renderer.prototype">module markdown-it.renderer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.renderer.prototype.render" id="apidoc.element.markdown-it.renderer.prototype.render">
        function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>render
        <span class="apidocSignatureSpan">(tokens, options, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (tokens, options, env) {
  var i, len, type,
      result = &#x27;&#x27;,
      rules = this.rules;

  for (i = 0, len = tokens.length; i &#x3c; len; i++) {
    type = tokens[i].type;

    if (type === &#x27;inline&#x27;) {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== &#x27;undefined&#x27;) {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Simple

```js
// node.js, &#x22;classic&#x22; way:
var MarkdownIt = require(&#x27;markdown-it&#x27;),
    md = new MarkdownIt();
var result = md.<span class="apidocCodeKeywordSpan">render</span>(&#x27;# markdown-it rulezz!&#x27;);

// node.js, the same, but with sugar:
var md = require(&#x27;markdown-it&#x27;)();
var result = md.render(&#x27;# markdown-it rulezz!&#x27;);

// browser without AMD, added to &#x22;window&#x22; on script load
// Note, there is no dash in &#x22;markdownit&#x22;.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.renderer.prototype.renderAttrs" id="apidoc.element.markdown-it.renderer.prototype.renderAttrs">
        function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderAttrs
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) { return &#x27;&#x27;; }

  result = &#x27;&#x27;;

  for (i = 0, l = token.attrs.length; i &#x3c; l; i++) {
    result += &#x27; &#x27; + escapeHtml(token.attrs[i][0]) + &#x27;=&#x22;&#x27; + escapeHtml(token.attrs[i][1]) + &#x27;&#x22;&#x27;;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var default_rules = {};


default_rules.code_inline = function (tokens, idx, options, env, slf) {
var token = tokens[idx];

return  &#x27;&#x3c;code&#x27; + slf.<span class="apidocCodeKeywordSpan">renderAttrs</span>(token) + &#x27;&#x3e;&#x27; +
        escapeHtml(tokens[idx].content) +
        &#x27;&#x3c;/code&#x3e;&#x27;;
};


default_rules.code_block = function (tokens, idx, options, env, slf) {
var token = tokens[idx];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.renderer.prototype.renderInline" id="apidoc.element.markdown-it.renderer.prototype.renderInline">
        function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderInline
        <span class="apidocSignatureSpan">(tokens, options, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderInline = function (tokens, options, env) {
  var type,
      result = &#x27;&#x27;,
      rules = this.rules;

  for (var i = 0, len = tokens.length; i &#x3c; len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== &#x27;undefined&#x27;) {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var result = md.render(&#x27;# markdown-it rulezz!&#x27;);
```

Single line rendering, without paragraph wrap:

```js
var md = require(&#x27;markdown-it&#x27;)();
var result = md.<span class="apidocCodeKeywordSpan">renderInline</span>(&#x27;__markdown-it__ rulezz!&#x27;);
```


### Init with presets and options

(*) presets define combinations of active rules and options. Can be
`&#x22;commonmark&#x22;`, `&#x22;zero&#x22;` or `&#x22;default&#x22;` (if skipped). See
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.renderer.prototype.renderInlineAsText" id="apidoc.element.markdown-it.renderer.prototype.renderInlineAsText">
        function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderInlineAsText
        <span class="apidocSignatureSpan">(tokens, options, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderInlineAsText = function (tokens, options, env) {
  var result = &#x27;&#x27;;

  for (var i = 0, len = tokens.length; i &#x3c; len; i++) {
    if (tokens[i].type === &#x27;text&#x27;) {
      result += tokens[i].content;
    } else if (tokens[i].type === &#x27;image&#x27;) {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// &#x22;alt&#x22; attr MUST be set, even if empty. Because it&#x27;s mandatory and
// should be placed on proper position for tests.
//
// Replace content with actual value

token.attrs[token.attrIndex(&#x27;alt&#x27;)][1] =
  slf.<span class="apidocCodeKeywordSpan">renderInlineAsText</span>(token.children, options, env);

return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
return options.xhtmlOut ? &#x27;&#x3c;br /&#x3e;\n&#x27; : &#x27;&#x3c;br&#x3e;\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.renderer.prototype.renderToken" id="apidoc.element.markdown-it.renderer.prototype.renderToken">
        function <span class="apidocSignatureSpan">markdown-it.renderer.prototype.</span>renderToken
        <span class="apidocSignatureSpan">(tokens, idx, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToken(tokens, idx, options) {
  var nextToken,
      result = &#x27;&#x27;,
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return &#x27;&#x27;;
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    &#x3e;
  //
  if (token.block &#x26;&#x26; token.nesting !== -1 &#x26;&#x26; idx &#x26;&#x26; tokens[idx - 1].hidden) {
    result += &#x27;\n&#x27;;
  }

  // Add token name, e.g. `&#x3c;img`
  result += (token.nesting === -1 ? &#x27;&#x3c;/&#x27; : &#x27;&#x3c;&#x27;) + token.tag;

  // Encode attributes, e.g. `&#x3c;img src=&#x22;foo&#x22;`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `&#x3c;img src=&#x22;foo&#x22; /`
  if (token.nesting === 0 &#x26;&#x26; options.xhtmlOut) {
    result += &#x27; /&#x27;;
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 &#x3c; tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === &#x27;inline&#x27; || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;

        } else if (nextToken.nesting === -1 &#x26;&#x26; nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `&#x3c;li&#x3e;&#x3c;/li&#x3e;`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? &#x27;&#x3e;\n&#x27; : &#x27;&#x3e;&#x27;;

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex(&#x27;alt&#x27;)][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.<span class="apidocCodeKeywordSpan">renderToken</span>(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? &#x27;&#x3c;br /&#x3e;\n&#x27; : &#x27;&#x3c;br&#x3e;\n&#x27;;
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.ruler" id="apidoc.module.markdown-it.ruler">module markdown-it.ruler</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.ruler.ruler" id="apidoc.element.markdown-it.ruler.ruler">
        function <span class="apidocSignatureSpan">markdown-it.</span>ruler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, &#x27;&#x27; for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.ruler.prototype" id="apidoc.module.markdown-it.ruler.prototype">module markdown-it.ruler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.__compile__" id="apidoc.element.markdown-it.ruler.prototype.__compile__">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>__compile__
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__compile__ = function () {
  var self = this;
  var chains = [ &#x27;&#x27; ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) { return; }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) &#x3c; 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      if (chain &#x26;&#x26; rule.alt.indexOf(chain) &#x3c; 0) { return; }

      self.__cache__[chain].push(rule.fn);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `&#x27;&#x27;` (empty string). It can&#x27;t be skipped. That&#x27;s
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.<span class="apidocCodeKeywordSpan">__compile__</span>();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.__find__" id="apidoc.element.markdown-it.ruler.prototype.__find__">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>__find__
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__find__ = function (name) {
  for (var i = 0; i &#x3c; this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * md.core.ruler.at(&#x27;replacements&#x27;, function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
var index = this.<span class="apidocCodeKeywordSpan">__find__</span>(name);
var opt = options || {};

if (index === -1) { throw new Error(&#x27;Parser rule not found: &#x27; + name); }

this.__rules__[index].fn = fn;
this.__rules__[index].alt = opt.alt || [];
this.__cache__ = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.after" id="apidoc.element.markdown-it.ruler.prototype.after">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>after
        <span class="apidocSignatureSpan">(afterName, ruleName, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) { throw new Error(&#x27;Parser rule not found: &#x27; + afterName); }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 });

 this.__cache__ = null;
};


/**
* Ruler.<span class="apidocCodeKeywordSpan">after</span>(afterName, ruleName, fn [, options])
* - afterName (String): new rule will be added after this one.
* - ruleName (String): name of added rule.
* - fn (Function): rule function.
* - options (Object): rule options (not mandatory).
*
* Add new rule to chain after one with given name. See also
* [[Ruler.before]], [[Ruler.push]].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.at" id="apidoc.element.markdown-it.ruler.prototype.at">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>at
        <span class="apidocSignatureSpan">(name, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) { throw new Error(&#x27;Parser rule not found: &#x27; + name); }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     self.__cache__[chain].push(rule.fn);
   });
 });
};


/**
* Ruler.<span class="apidocCodeKeywordSpan">at</span>(name, fn [, options])
* - name (String): rule name to replace.
* - fn (Function): new rule function.
* - options (Object): new rule options (not mandatory).
*
* Replace rule by name with new function &#x26; options. Throws error if name not
* found.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.before" id="apidoc.element.markdown-it.ruler.prototype.before">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>before
        <span class="apidocSignatureSpan">(beforeName, ruleName, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) { throw new Error(&#x27;Parser rule not found: &#x27; + beforeName); }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.__rules__[index].fn = fn;
 this.__rules__[index].alt = opt.alt || [];
 this.__cache__ = null;
};


/**
* Ruler.<span class="apidocCodeKeywordSpan">before</span>(beforeName, ruleName, fn [, options])
* - beforeName (String): new rule will be added before this one.
* - ruleName (String): name of added rule.
* - fn (Function): rule function.
* - options (Object): rule options (not mandatory).
*
* Add new rule to chain before one with given name. See also
* [[Ruler.after]], [[Ruler.push]].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.disable" id="apidoc.element.markdown-it.ruler.prototype.disable">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>disable
        <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx &#x3c; 0) {
      if (ignoreInvalid) { return; }
      throw new Error(&#x27;Rules manager: invalid rule name &#x27; + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

By default all rules are enabled, but can be restricted by options. On plugin
load all its rules are enabled automatically.

```js
// Activate/deactivate rules, with curring
var md = require(&#x27;markdown-it&#x27;)()
          .<span class="apidocCodeKeywordSpan">disable</span>([ &#x27;link&#x27;, &#x27;image&#x27; ])
          .enable([ &#x27;link&#x27; ])
          .enable(&#x27;image&#x27;);

// Enable everything
md = require(&#x27;markdown-it&#x27;)({
html: true,
linkify: true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.enable" id="apidoc.element.markdown-it.ruler.prototype.enable">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>enable
        <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx &#x3c; 0) {
      if (ignoreInvalid) { return; }
      throw new Error(&#x27;Rules manager: invalid rule name &#x27; + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
By default all rules are enabled, but can be restricted by options. On plugin
load all its rules are enabled automatically.

```js
// Activate/deactivate rules, with curring
var md = require(&#x27;markdown-it&#x27;)()
          .disable([ &#x27;link&#x27;, &#x27;image&#x27; ])
          .<span class="apidocCodeKeywordSpan">enable</span>([ &#x27;link&#x27; ])
          .enable(&#x27;image&#x27;);

// Enable everything
md = require(&#x27;markdown-it&#x27;)({
html: true,
linkify: true,
typographer: true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.enableOnly" id="apidoc.element.markdown-it.ruler.prototype.enableOnly">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>enableOnly
        <span class="apidocSignatureSpan">(list, ignoreInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  this.__rules__.forEach(function (rule) { rule.enabled = false; });

  this.enable(list, ignoreInvalid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!presets) { throw new Error(&#x27;Wrong `markdown-it` preset, can\&#x27;t be empty&#x27;); }

if (presets.options) { self.set(presets.options); }

if (presets.components) {
  Object.keys(presets.components).forEach(function (name) {
    if (presets.components[name].rules) {
      self[name].ruler.<span class="apidocCodeKeywordSpan">enableOnly</span>(presets.components[name].rules);
    }
    if (presets.components[name].rules2) {
      self[name].ruler2.enableOnly(presets.components[name].rules2);
    }
  });
}
return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.getRules" id="apidoc.element.markdown-it.ruler.prototype.getRules">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>getRules
        <span class="apidocSignatureSpan">(chainName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
var ok, i,
    rules = this.ruler.<span class="apidocCodeKeywordSpan">getRules</span>(&#x27;&#x27;),
    len = rules.length,
    line = startLine,
    hasEmptyLines = false,
    maxNesting = state.md.options.maxNesting;

while (line &#x3c; endLine) {
  state.line = line = state.skipEmptyLines(line);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.ruler.prototype.push" id="apidoc.element.markdown-it.ruler.prototype.push">
        function <span class="apidocSignatureSpan">markdown-it.ruler.prototype.</span>push
        <span class="apidocSignatureSpan">(ruleName, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

4.0.0 / 2015-03-11
------------------

- Breaking internal API changes. See [v4 migration notes](https://github.com/markdown-it/markdown-it/blob/master/docs/4.0_migration
.md). In usual case you will need to update plugins.
- Token internals changed
- Unified the most of renderer methods.
- Changed tokens creation - use `state.<span class="apidocCodeKeywordSpan">push</span>(...)` (see sources)
- Moved `normalizeUrl()` to root class as `.normalizeLink()` &#x26;
  added `normalizeLinkText()` method.
- Moved `.validateUrl()` to root class and simplified logic - no more need to
  replace entities.
- Joined md unescape &#x26; replace entities logic to `utils.unescapeAll()`.
- Removed `replaceEntities()` in `utils`.
- `md.utils.lib` now exposes useful libs for plugins.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_block" id="apidoc.module.markdown-it.state_block">module markdown-it.state_block</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_block.state_block" id="apidoc.element.markdown-it.state_block.state_block">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_block
        <span class="apidocSignatureSpan">(src, md, env, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It&#x27;s used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn&#x27;t any)

  // can be &#x27;blockquote&#x27;, &#x27;list&#x27;, &#x27;root&#x27;, &#x27;paragraph&#x27; or &#x27;reference&#x27;
  // used in lists to determine if they interrupt a paragraph
  this.parentType = &#x27;root&#x27;;

  this.level = 0;

  // renderer
  this.result = &#x27;&#x27;;

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos &#x3c; len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don&#x27;t count last fake line
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_block.prototype" id="apidoc.module.markdown-it.state_block.prototype">module markdown-it.state_block.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.Token" id="apidoc.element.markdown-it.state_block.prototype.Token">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>Token
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(type, tag, nesting) {
<span class="apidocCodeCommentSpan">  /**
   * Token#type -&#x3e; String
   *
   * Type of the token (string, e.g. &#x22;paragraph_open&#x22;)
   **/
</span>  this.type     = type;

  /**
   * Token#tag -&#x3e; String
   *
   * html tag name, e.g. &#x22;p&#x22;
   **/
  this.tag      = tag;

  /**
   * Token#attrs -&#x3e; Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -&#x3e; Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -&#x3e; Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -&#x3e; Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -&#x3e; Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -&#x3e; String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = &#x27;&#x27;;

  /**
   * Token#markup -&#x3e; String
   *
   * &#x27;*&#x27; or &#x27;_&#x27; for emphasis, fence string for fence, etc.
   **/
  this.markup   = &#x27;&#x27;;

  /**
   * Token#info -&#x3e; String
   *
   * fence infostring
   **/
  this.info     = &#x27;&#x27;;

  /**
   * Token#meta -&#x3e; Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -&#x3e; Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -&#x3e; Boolean
   *
   * If it&#x27;s true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;


module.exports = function block(state) {
var token;

if (state.inlineMode) {
  token          = new state.<span class="apidocCodeKeywordSpan">Token</span>(&#x27;inline&#x27;, &#x27;&#x27;, 0);
  token.content  = state.src;
  token.map      = [ 0, 1 ];
  token.children = [];
  state.tokens.push(token);
} else {
  state.md.block.parse(state.src, state.md, state.env, state.tokens);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.getLines" id="apidoc.element.markdown-it.state_block.prototype.getLines">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>getLines
        <span class="apidocSignatureSpan">(begin, end, indent, keepLastLF)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart,
      line = begin;

  if (begin &#x3e;= end) {
    return &#x27;&#x27;;
  }

  queue = new Array(end - begin);

  for (i = 0; line &#x3c; end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 &#x3c; end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first &#x3c; last &#x26;&#x26; lineIndent &#x3c; indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart &#x3c; this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent &#x3e; indent) {
      // partially expanding tabs in code blocks, e.g &#x27;\t\tfoobar&#x27;
      // with indent=2 becomes &#x27;  \tfoobar&#x27;
      queue[i] = new Array(lineIndent - indent + 1).join(&#x27; &#x27;) + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    break;
  }

  state.line = last;

  token         = state.push(&#x27;code_block&#x27;, &#x27;code&#x27;, 0);
  token.content = state.<span class="apidocCodeKeywordSpan">getLines</span>(startLine, last, 4 + state.blkIndent, true);
  token.map     = [ startLine, state.line ];

  return true;
};

},{}],20:[function(require,module,exports){
// fences (``` lang, ~~~ lang)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.isEmpty" id="apidoc.element.markdown-it.state_block.prototype.isEmpty">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] &#x3e;= this.eMarks[line];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// set state.tight iff we had an empty line before current tag
// i.e. latest empty line should not count
state.tight = !hasEmptyLines;

// paragraph might &#x22;eat&#x22; one newline after it in nested lists
if (state.<span class="apidocCodeKeywordSpan">isEmpty</span>(state.line - 1)) {
  hasEmptyLines = true;
}

line = state.line;

if (line &#x3c; endLine &#x26;&#x26; state.isEmpty(line)) {
  hasEmptyLines = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.push" id="apidoc.element.markdown-it.state_block.prototype.push">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>push
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting &#x3c; 0) { this.level--; }
  token.level = this.level;
  if (nesting &#x3e; 0) { this.level++; }

  this.tokens.push(token);
  return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

4.0.0 / 2015-03-11
------------------

- Breaking internal API changes. See [v4 migration notes](https://github.com/markdown-it/markdown-it/blob/master/docs/4.0_migration
.md). In usual case you will need to update plugins.
- Token internals changed
- Unified the most of renderer methods.
- Changed tokens creation - use `state.<span class="apidocCodeKeywordSpan">push</span>(...)` (see sources)
- Moved `normalizeUrl()` to root class as `.normalizeLink()` &#x26;
  added `normalizeLinkText()` method.
- Moved `.validateUrl()` to root class and simplified logic - no more need to
  replace entities.
- Joined md unescape &#x26; replace entities logic to `utils.unescapeAll()`.
- Removed `replaceEntities()` in `utils`.
- `md.utils.lib` now exposes useful libs for plugins.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.skipChars" id="apidoc.element.markdown-it.state_block.prototype.skipChars">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipChars
        <span class="apidocSignatureSpan">(pos, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipChars(pos, code) {
  for (var max = this.src.length; pos &#x3c; max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (marker !== 0x7E/* ~ */ &#x26;&#x26; marker !== 0x60 /* ` */) {
  return false;
}

// scan marker length
mem = pos;
pos = state.<span class="apidocCodeKeywordSpan">skipChars</span>(pos, marker);

len = pos - mem;

if (len &#x3c; 3) { return false; }

markup = state.src.slice(mem, pos);
params = state.src.slice(pos, max);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.skipCharsBack" id="apidoc.element.markdown-it.state_block.prototype.skipCharsBack">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipCharsBack
        <span class="apidocSignatureSpan">(pos, code, min)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipCharsBack(pos, code, min) {
  if (pos &#x3c;= min) { return pos; }

  while (pos &#x3e; min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level &#x3e; 6 || (pos &#x3c; max &#x26;&#x26; !isSpace(ch))) { return false; }

if (silent) { return true; }

// Let&#x27;s cut tails like &#x27;    ###  &#x27; from the end of string

max = state.skipSpacesBack(max, pos);
tmp = state.<span class="apidocCodeKeywordSpan">skipCharsBack</span>(max, 0x23, pos); // #
if (tmp &#x3e; pos &#x26;&#x26; isSpace(state.src.charCodeAt(tmp - 1))) {
  max = tmp;
}

state.line = startLine + 1;

token        = state.push(&#x27;heading_open&#x27;, &#x27;h&#x27; + String(level), 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.skipEmptyLines" id="apidoc.element.markdown-it.state_block.prototype.skipEmptyLines">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipEmptyLines
        <span class="apidocSignatureSpan">(from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipEmptyLines(from) {
  for (var max = this.lineMax; from &#x3c; max; from++) {
    if (this.bMarks[from] + this.tShift[from] &#x3c; this.eMarks[from]) {
      break;
    }
  }
  return from;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  rules = this.ruler.getRules(&#x27;&#x27;),
  len = rules.length,
  line = startLine,
  hasEmptyLines = false,
  maxNesting = state.md.options.maxNesting;

  while (line &#x3c; endLine) {
state.line = line = state.<span class="apidocCodeKeywordSpan">skipEmptyLines</span>(line);
if (line &#x3e;= endLine) { break; }

// Termination condition for nested calls.
// Nested calls currently used for blockquotes &#x26; lists
if (state.sCount[line] &#x3c; state.blkIndent) { break; }

// If nesting level exceeded - skip tail to the end. That&#x27;s not ordinary
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.skipSpaces" id="apidoc.element.markdown-it.state_block.prototype.skipSpaces">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipSpaces
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos &#x3c; max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) { break; }
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  pos = state.skipChars(pos, marker);

  // closing code fence must be at least as long as the opening one
  if (pos - mem &#x3c; len) { continue; }

  // make sure tail has spaces only
  pos = state.<span class="apidocCodeKeywordSpan">skipSpaces</span>(pos);

  if (pos &#x3c; max) { continue; }

  haveEndMarker = true;
  // found!
  break;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_block.prototype.skipSpacesBack" id="apidoc.element.markdown-it.state_block.prototype.skipSpacesBack">
        function <span class="apidocSignatureSpan">markdown-it.state_block.prototype.</span>skipSpacesBack
        <span class="apidocSignatureSpan">(pos, min)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipSpacesBack(pos, min) {
  if (pos &#x3c;= min) { return pos; }

  while (pos &#x3e; min) {
    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (level &#x3e; 6 || (pos &#x3c; max &#x26;&#x26; !isSpace(ch))) { return false; }

if (silent) { return true; }

// Let&#x27;s cut tails like &#x27;    ###  &#x27; from the end of string

max = state.<span class="apidocCodeKeywordSpan">skipSpacesBack</span>(max, pos);
tmp = state.skipCharsBack(max, 0x23, pos); // #
if (tmp &#x3e; pos &#x26;&#x26; isSpace(state.src.charCodeAt(tmp - 1))) {
  max = tmp;
}

state.line = startLine + 1;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_core" id="apidoc.module.markdown-it.state_core">module markdown-it.state_core</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_core.state_core" id="apidoc.element.markdown-it.state_core.state_core">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_core
        <span class="apidocSignatureSpan">(src, md, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_core.prototype" id="apidoc.module.markdown-it.state_core.prototype">module markdown-it.state_core.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_core.prototype.Token" id="apidoc.element.markdown-it.state_core.prototype.Token">
        function <span class="apidocSignatureSpan">markdown-it.state_core.prototype.</span>Token
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(type, tag, nesting) {
<span class="apidocCodeCommentSpan">  /**
   * Token#type -&#x3e; String
   *
   * Type of the token (string, e.g. &#x22;paragraph_open&#x22;)
   **/
</span>  this.type     = type;

  /**
   * Token#tag -&#x3e; String
   *
   * html tag name, e.g. &#x22;p&#x22;
   **/
  this.tag      = tag;

  /**
   * Token#attrs -&#x3e; Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -&#x3e; Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -&#x3e; Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -&#x3e; Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -&#x3e; Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -&#x3e; String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = &#x27;&#x27;;

  /**
   * Token#markup -&#x3e; String
   *
   * &#x27;*&#x27; or &#x27;_&#x27; for emphasis, fence string for fence, etc.
   **/
  this.markup   = &#x27;&#x27;;

  /**
   * Token#info -&#x3e; String
   *
   * fence infostring
   **/
  this.info     = &#x27;&#x27;;

  /**
   * Token#meta -&#x3e; Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -&#x3e; Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -&#x3e; Boolean
   *
   * If it&#x27;s true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;


module.exports = function block(state) {
var token;

if (state.inlineMode) {
  token          = new state.<span class="apidocCodeKeywordSpan">Token</span>(&#x27;inline&#x27;, &#x27;&#x27;, 0);
  token.content  = state.src;
  token.map      = [ 0, 1 ];
  token.children = [];
  state.tokens.push(token);
} else {
  state.md.block.parse(state.src, state.md, state.env, state.tokens);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_inline" id="apidoc.module.markdown-it.state_inline">module markdown-it.state_inline</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_inline.state_inline" id="apidoc.element.markdown-it.state_inline.state_inline">
        function <span class="apidocSignatureSpan">markdown-it.</span>state_inline
        <span class="apidocSignatureSpan">(src, md, env, outTokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = &#x27;&#x27;;
  this.pendingLevel = 0;

  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  this.delimiters = [];   // Emphasis-like delimiters
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.state_inline.prototype" id="apidoc.module.markdown-it.state_inline.prototype">module markdown-it.state_inline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.state_inline.prototype.Token" id="apidoc.element.markdown-it.state_inline.prototype.Token">
        function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>Token
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(type, tag, nesting) {
<span class="apidocCodeCommentSpan">  /**
   * Token#type -&#x3e; String
   *
   * Type of the token (string, e.g. &#x22;paragraph_open&#x22;)
   **/
</span>  this.type     = type;

  /**
   * Token#tag -&#x3e; String
   *
   * html tag name, e.g. &#x22;p&#x22;
   **/
  this.tag      = tag;

  /**
   * Token#attrs -&#x3e; Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -&#x3e; Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -&#x3e; Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -&#x3e; Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -&#x3e; Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -&#x3e; String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = &#x27;&#x27;;

  /**
   * Token#markup -&#x3e; String
   *
   * &#x27;*&#x27; or &#x27;_&#x27; for emphasis, fence string for fence, etc.
   **/
  this.markup   = &#x27;&#x27;;

  /**
   * Token#info -&#x3e; String
   *
   * fence infostring
   **/
  this.info     = &#x27;&#x27;;

  /**
   * Token#meta -&#x3e; Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -&#x3e; Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -&#x3e; Boolean
   *
   * If it&#x27;s true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;


module.exports = function block(state) {
var token;

if (state.inlineMode) {
  token          = new state.<span class="apidocCodeKeywordSpan">Token</span>(&#x27;inline&#x27;, &#x27;&#x27;, 0);
  token.content  = state.src;
  token.map      = [ 0, 1 ];
  token.children = [];
  state.tokens.push(token);
} else {
  state.md.block.parse(state.src, state.md, state.env, state.tokens);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_inline.prototype.push" id="apidoc.element.markdown-it.state_inline.prototype.push">
        function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>push
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting &#x3c; 0) { this.level--; }
  token.level = this.level;
  if (nesting &#x3e; 0) { this.level++; }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

4.0.0 / 2015-03-11
------------------

- Breaking internal API changes. See [v4 migration notes](https://github.com/markdown-it/markdown-it/blob/master/docs/4.0_migration
.md). In usual case you will need to update plugins.
- Token internals changed
- Unified the most of renderer methods.
- Changed tokens creation - use `state.<span class="apidocCodeKeywordSpan">push</span>(...)` (see sources)
- Moved `normalizeUrl()` to root class as `.normalizeLink()` &#x26;
  added `normalizeLinkText()` method.
- Moved `.validateUrl()` to root class and simplified logic - no more need to
  replace entities.
- Joined md unescape &#x26; replace entities logic to `utils.unescapeAll()`.
- Removed `replaceEntities()` in `utils`.
- `md.utils.lib` now exposes useful libs for plugins.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_inline.prototype.pushPending" id="apidoc.element.markdown-it.state_inline.prototype.pushPending">
        function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>pushPending
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushPending = function () {
  var token = new Token(&#x27;text&#x27;, &#x27;&#x27;, 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = &#x27;&#x27;;
  return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     continue;
   }

   state.pending += state.src[state.pos++];
 }

 if (state.pending) {
   state.<span class="apidocCodeKeywordSpan">pushPending</span>();
 }
};


/**
* ParserInline.parse(str, md, env, outTokens)
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.state_inline.prototype.scanDelims" id="apidoc.element.markdown-it.state_inline.prototype.scanDelims">
        function <span class="apidocSignatureSpan">markdown-it.state_inline.prototype.</span>scanDelims
        <span class="apidocSignatureSpan">(start, canSplitWord)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scanDelims = function (start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close,
      isLastWhiteSpace, isLastPunctChar,
      isNextWhiteSpace, isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start &#x3e; 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos &#x3c; max &#x26;&#x26; this.src.charCodeAt(pos) === marker) { pos++; }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos &#x3c; max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open  = left_flanking  &#x26;&#x26; (!right_flanking || isLastPunctChar);
    can_close = right_flanking &#x26;&#x26; (!left_flanking  || isNextPunctChar);
  } else {
    can_open  = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open:  can_open,
    can_close: can_close,
    length:    count
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  start = state.pos,
  marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ &#x26;&#x26; marker !== 0x2A /* * */) { return false; }

  scanned = state.<span class="apidocCodeKeywordSpan">scanDelims</span>(state.pos, marker === 0x2A);

  for (i = 0; i &#x3c; scanned.length; i++) {
token         = state.push(&#x27;text&#x27;, &#x27;&#x27;, 0);
token.content = String.fromCharCode(marker);

state.delimiters.push({
  // Char code of the starting marker (number).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.strikethrough" id="apidoc.module.markdown-it.strikethrough">module markdown-it.strikethrough</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.strikethrough.postProcess" id="apidoc.element.markdown-it.strikethrough.postProcess">
        function <span class="apidocSignatureSpan">markdown-it.strikethrough.</span>postProcess
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function strikethrough(state) {
  var i, j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i &#x3c; max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E/* ~ */) {
      continue;
    }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token         = state.tokens[startDelim.token];
    token.type    = &#x27;s_open&#x27;;
    token.tag     = &#x27;s&#x27;;
    token.nesting = 1;
    token.markup  = &#x27;~~&#x27;;
    token.content = &#x27;&#x27;;

    token         = state.tokens[endDelim.token];
    token.type    = &#x27;s_close&#x27;;
    token.tag     = &#x27;s&#x27;;
    token.nesting = -1;
    token.markup  = &#x27;~~&#x27;;
    token.content = &#x27;&#x27;;

    if (state.tokens[endDelim.token - 1].type === &#x27;text&#x27; &#x26;&#x26;
        state.tokens[endDelim.token - 1].content === &#x27;~&#x27;) {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it&#x27;s splitted
  // like this: `~~~~~` -&#x3e; `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j &#x3c; state.tokens.length &#x26;&#x26; state.tokens[j].type === &#x27;s_close&#x27;) {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.strikethrough.tokenize" id="apidoc.element.markdown-it.strikethrough.tokenize">
        function <span class="apidocSignatureSpan">markdown-it.strikethrough.</span>tokenize
        <span class="apidocSignatureSpan">(state, silent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function strikethrough(state, silent) {
  var i, scanned, token, len, ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x7E/* ~ */) { return false; }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len &#x3c; 2) { return false; }

  if (len % 2) {
    token         = state.push(&#x27;text&#x27;, &#x27;&#x27;, 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i &#x3c; len; i += 2) {
    token         = state.push(&#x27;text&#x27;, &#x27;&#x27;, 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump:   i,
      token:  state.tokens.length - 1,
      level:  state.level,
      end:    -1,
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.<span class="apidocCodeKeywordSpan">tokenize</span>(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require(&#x27;./rules_block/state_block&#x27;);


module.exports = ParserBlock;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.token" id="apidoc.module.markdown-it.token">module markdown-it.token</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.token.token" id="apidoc.element.markdown-it.token.token">
        function <span class="apidocSignatureSpan">markdown-it.</span>token
        <span class="apidocSignatureSpan">(type, tag, nesting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(type, tag, nesting) {
<span class="apidocCodeCommentSpan">  /**
   * Token#type -&#x3e; String
   *
   * Type of the token (string, e.g. &#x22;paragraph_open&#x22;)
   **/
</span>  this.type     = type;

  /**
   * Token#tag -&#x3e; String
   *
   * html tag name, e.g. &#x22;p&#x22;
   **/
  this.tag      = tag;

  /**
   * Token#attrs -&#x3e; Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -&#x3e; Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -&#x3e; Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -&#x3e; Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -&#x3e; Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -&#x3e; String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = &#x27;&#x27;;

  /**
   * Token#markup -&#x3e; String
   *
   * &#x27;*&#x27; or &#x27;_&#x27; for emphasis, fence string for fence, etc.
   **/
  this.markup   = &#x27;&#x27;;

  /**
   * Token#info -&#x3e; String
   *
   * fence infostring
   **/
  this.info     = &#x27;&#x27;;

  /**
   * Token#meta -&#x3e; Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -&#x3e; Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -&#x3e; Boolean
   *
   * If it&#x27;s true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.token.prototype" id="apidoc.module.markdown-it.token.prototype">module markdown-it.token.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.token.prototype.attrGet" id="apidoc.element.markdown-it.token.prototype.attrGet">
        function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrGet
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx &#x3e;= 0) {
    value = this.attrs[idx][1];
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Process `\r` the same way as `\n` and `\r\n\`, #252.


6.0.4 / 2016-05-30
------------------

- Added `Token.<span class="apidocCodeKeywordSpan">attrGet</span>()` method for convenience, #251.


6.0.3 / 2016-05-30
------------------

- Security fix: possible ReDOS in `linkify-it` (forced bump of `linkify-it` &#x26;
`uc-micro` dependencies). New installs will use fixed packages automatically,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.token.prototype.attrIndex" id="apidoc.element.markdown-it.token.prototype.attrIndex">
        function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrIndex
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) { return -1; }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i &#x3c; len; i++) {
    if (attrs[i][0] === name) { return i; }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return highlighted + &#x27;\n&#x27;;
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
i        = token.<span class="apidocCodeKeywordSpan">attrIndex</span>(&#x27;class&#x27;);
tmpAttrs = token.attrs ? token.attrs.slice() : [];

if (i &#x3c; 0) {
  tmpAttrs.push([ &#x27;class&#x27;, options.langPrefix + langName ]);
} else {
  tmpAttrs[i][1] += &#x27; &#x27; + options.langPrefix + langName;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.token.prototype.attrJoin" id="apidoc.element.markdown-it.token.prototype.attrJoin">
        function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrJoin
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx &#x3c; 0) {
    this.attrPush([ name, value ]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + &#x27; &#x27; + value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Fixed nesting limit check in inline blocks, #197.
- Fixed posible tail loss in CLI ouput.


5.1.0 / 2016-01-07
------------------

- Token: added `.attrSet()` &#x26; `.<span class="apidocCodeKeywordSpan">attrJoin</span>()` methods.
- Highlighter: allow wrapper override (if result starts with &#x22;&#x3c;pre&#x22;).


5.0.3 / 2016-01-04
------------------

- Allow single column and mismatched columns count in tables.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.token.prototype.attrPush" id="apidoc.element.markdown-it.token.prototype.attrPush">
        function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrPush
        <span class="apidocSignatureSpan">(attrData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [ attrData ];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (attrs[i][0] === name) { return i; }
}
return -1;
};


/**
 * Token.<span class="apidocCodeKeywordSpan">attrPush</span>(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
if (this.attrs) {
  this.attrs.push(attrData);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.token.prototype.attrSet" id="apidoc.element.markdown-it.token.prototype.attrSet">
        function <span class="apidocSignatureSpan">markdown-it.token.prototype.</span>attrSet
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [ name, value ];

  if (idx &#x3c; 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Fixed nesting limit check in inline blocks, #197.
- Fixed posible tail loss in CLI ouput.


5.1.0 / 2016-01-07
------------------

- Token: added `.<span class="apidocCodeKeywordSpan">attrSet</span>()` &#x26; `.attrJoin()` methods.
- Highlighter: allow wrapper override (if result starts with &#x22;&#x3c;pre&#x22;).


5.0.3 / 2016-01-04
------------------

- Allow single column and mismatched columns count in tables.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.markdown-it.utils" id="apidoc.module.markdown-it.utils">module markdown-it.utils</a></h1>


    <h2>
        <a href="#apidoc.element.markdown-it.utils.arrayReplaceAt" id="apidoc.element.markdown-it.utils.arrayReplaceAt">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>arrayReplaceAt
        <span class="apidocSignatureSpan">(src, pos, newElements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.assign" id="apidoc.element.markdown-it.utils.assign">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>assign
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== &#x27;object&#x27;) {
      throw new TypeError(source + &#x27;must be object&#x27;);
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * MarkdownIt#helpers -&#x3e; helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.<span class="apidocCodeKeywordSpan">assign</span>({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.escapeHtml" id="apidoc.element.markdown-it.utils.escapeHtml">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>escapeHtml
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      try {
        return &#x27;&#x3c;pre class=&#x22;hljs&#x22;&#x3e;&#x3c;code&#x3e;&#x27; +
               hljs.highlight(lang, str, true).value +
               &#x27;&#x3c;/code&#x3e;&#x3c;/pre&#x3e;&#x27;;
      } catch (__) {}
    }

    return &#x27;&#x3c;pre class=&#x22;hljs&#x22;&#x3e;&#x3c;code&#x3e;&#x27; + md.utils.<span class="apidocCodeKeywordSpan">escapeHtml
</span>(str) + &#x27;&#x3c;/code&#x3e;&#x3c;/pre&#x3e;&#x27;;
  }
});
```

### Linkify

`linkify: true` uses [linkify-it](https://github.com/markdown-it/linkify-it). To
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.escapeRE" id="apidoc.element.markdown-it.utils.escapeRE">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>escapeRE
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.fromCodePoint" id="apidoc.element.markdown-it.utils.fromCodePoint">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>fromCodePoint
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromCodePoint(c) {
<span class="apidocCodeCommentSpan">  /*eslint no-bitwise:0*/
</span>  if (c &#x3e; 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c &#x3e;&#x3e; 10),
        surrogate2 = 0xdc00 + (c &#x26; 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.has" id="apidoc.element.markdown-it.utils.has">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>has
        <span class="apidocSignatureSpan">(object, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function has(object, key) {
  return _hasOwnProperty.call(object, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isMdAsciiPunct" id="apidoc.element.markdown-it.utils.isMdAsciiPunct">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isMdAsciiPunct
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* &#x22; */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* &#x26; */:
    case 0x27/* &#x27; */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* &#x3c; */:
    case 0x3D/* = */:
    case 0x3E/* &#x3e; */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isPunctChar" id="apidoc.element.markdown-it.utils.isPunctChar">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isPunctChar
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isSpace" id="apidoc.element.markdown-it.utils.isSpace">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isSpace
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isString" id="apidoc.element.markdown-it.utils.isString">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isString
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(obj) { return _class(obj) === &#x27;[object String]&#x27;; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 **/
function MarkdownIt(presetName, options) {
if (!(this instanceof MarkdownIt)) {
  return new MarkdownIt(presetName, options);
}

if (!options) {
  if (!utils.<span class="apidocCodeKeywordSpan">isString</span>(presetName)) {
    options = presetName || {};
    presetName = &#x27;default&#x27;;
  }
}

/**
 * MarkdownIt#inline -&#x3e; ParserInline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isValidEntityCode" id="apidoc.element.markdown-it.utils.isValidEntityCode">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isValidEntityCode
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isValidEntityCode(c) {
<span class="apidocCodeCommentSpan">  /*eslint no-bitwise:0*/
</span>  // broken sequence
  if (c &#x3e;= 0xD800 &#x26;&#x26; c &#x3c;= 0xDFFF) { return false; }
  // never used
  if (c &#x3e;= 0xFDD0 &#x26;&#x26; c &#x3c;= 0xFDEF) { return false; }
  if ((c &#x26; 0xFFFF) === 0xFFFF || (c &#x26; 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c &#x3e;= 0x00 &#x26;&#x26; c &#x3c;= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c &#x3e;= 0x0E &#x26;&#x26; c &#x3c;= 0x1F) { return false; }
  if (c &#x3e;= 0x7F &#x26;&#x26; c &#x3c;= 0x9F) { return false; }
  // out of range
  if (c &#x3e; 0x10FFFF) { return false; }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.isWhiteSpace" id="apidoc.element.markdown-it.utils.isWhiteSpace">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>isWhiteSpace
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWhiteSpace(code) {
  if (code &#x3e;= 0x2000 &#x26;&#x26; code &#x3c;= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.normalizeReference" id="apidoc.element.markdown-it.utils.normalizeReference">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>normalizeReference
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, &#x27; &#x27;).toUpperCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.unescapeAll" id="apidoc.element.markdown-it.utils.unescapeAll">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>unescapeAll
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescapeAll(str) {
  if (str.indexOf(&#x27;\\&#x27;) &#x3c; 0 &#x26;&#x26; str.indexOf(&#x27;&#x26;&#x27;) &#x3c; 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Token internals changed
- Unified the most of renderer methods.
- Changed tokens creation - use `state.push(...)` (see sources)
- Moved `normalizeUrl()` to root class as `.normalizeLink()` &#x26;
  added `normalizeLinkText()` method.
- Moved `.validateUrl()` to root class and simplified logic - no more need to
  replace entities.
- Joined md unescape &#x26; replace entities logic to `utils.<span class="apidocCodeKeywordSpan">unescapeAll</span>()`.
- Removed `replaceEntities()` in `utils`.
- `md.utils.lib` now exposes useful libs for plugins.
- Use entities data from external package.
- Fixed emphasis regression, caused by CM v0.18 spec (#65).


3.1.0 / 2015-03-05
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.markdown-it.utils.unescapeMd" id="apidoc.element.markdown-it.utils.unescapeMd">
        function <span class="apidocSignatureSpan">markdown-it.utils.</span>unescapeMd
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescapeMd(str) {
  if (str.indexOf(&#x27;\\&#x27;) &#x3c; 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, &#x27;$1&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
